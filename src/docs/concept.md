# Архітектурний концепт

# Візія

**Canvas OS** — нескінченна інтерактивна канва, де будь-який файл, процес чи агент є вузлом, а стрілка між ними — живим каналом даних. Система, яка масштабується від індивідуального десктоп-інструмента до багатокористувацької мультиагентної лабораторії.

***

# Основні принципи

1. **Живий граф** — усе є вузлом-агентом: файл, автомат, скрипт, віджет, LLM або сторонній сервіс.
2. **Канали-потоки** — стрілки/ребра на канві — це реактивні канали передачі повідомлень (подій, масивів, сигналів).
3. **Редагування на гарячу** — можна змінювати код вузла або структуру графа у реальному часі без зупинки системи.
4. **Симуляції у WebWorker** — важка математика (клітинні автомати, агентні моделі) виконується окремо від UI, щоб зберігати FPS.
5. **Реактивна архітектура** — зв’язки та поведінка вузлів будуються через RxJS (інкрементно) або hot-recompile всього графа при масових змінах.
6. **Гнучкість для майбутнього** — легко додаються нові типи вузлів (плагіни), нові патерни сигналів (TTL, згасання, стохастика), шарування, інтеграція LLM та розподілення.

***

# Технічний стек

* **ElectronJS** (Win/macOS/Linux, офлайн-перший)
* **React 18+** (renderer, UI)
* **tldraw** (канва з support custom shapes + custom renderer)
* **RxJS** (реактивний data-flow між вузлами)
* **Web Workers / WASM** (обчислювальні вузли)
* **Monaco Editor** (live-кодинг вузлів)
* **Zustand/Signia** (глобальний state-менеджмент)

***

# Архітектурна схема

```mermaid
graph TD
  A[tldraw Canvas] --> B[GraphAPI]
  B --> C[RxJS Streams / Subscriptions]
  C --> D[Worker Shells]
  D --> E[Обчислення / Симуляції (Automata, Agent-based)]
  B --> F[Monaco Editor]
  B --> G[FileSystem/Clipboard/External]
```

***

# Node/Edge Dataflow – патерни й рішення

### 1. Інкрементний dataflow (edge = Subscription)

* Кожен вузол — свій Subject (ін/аут).
* Edge — це підписка між out\$ і in\$ (додається/видаляється O(1)).
* Вузол може змінити свою логіку на гарячу (`fn$.next(newFn)` через RxJS).
* Edge може мати параметри: згасання сигналу, затримка, TTL тощо.

### 2. Hot-recompile пайплайна

* Усі зміни структури зберігаються у BehaviorSubject\<Graph>.
* Зміна графа → миттєве пересоздання пайплайна через switchMap(buildPipeline).
* Гарантований чистий стан, undo/redo, serializability.
* Працює швидко навіть для великих масивних змін (1000+ вузлів/ребер).

### 3. Гаряче редагування коду вузлів (live-coding)

* Кожен обчислювальний вузол живе у Web Worker з shell’ом.
* Код вузла змінюється на льоту: compile → BlobURL → import() → миттєво запускається нова версія.
* Можливо зберігати/відновлювати state між версіями (гаряче оновлення алгоритму).

### 4. Мультиагентність і патерни взаємодії

* Граф підтримує передачу сигналу з загасанням по відстані, TTL, стохастичне розсіювання, кастомні черги подій тощо (оператори RxJS).
* Підтримка composite agents (агенти-вузли-графи всередині графа).
* Швидке видалення/додавання груп вузлів (Paste, Import, Live Edit).

***

# Продуктивність

* Всі обчислення симуляції — у Web Worker / WASM (0% CPU у UI).
* Передача даних — пакетами (frame, chunk), а не поодинокі клітинки.
* RxJS використовується на рівні сигналів між вузлами/edge, але не на кожну клітинку (hot path = raw loop).
* UI малює preview/visualization з мінімумом ререндерів (tldraw, canvas, WebGL).
* Пайплайн редагується інкрементно або через повний hot-recompile — обидва способи підтримуються і масштабуються.

***

# Безпека та стабільність

* `contextIsolation: true`, `sandbox: true` в Electron.
* Кожен Worker – sandboxed, не має доступу до Node API (тільки через contextBridge).
* Відновлення попередньої ревізії при падінні коду вузла.
* Строгий пул та контроль Subscription для уникнення memory leak.

***

# Плагінність та extensibility

* Новий тип вузла — це функція або модуль (npm-пакет) із API `process(msg, ctx)`.
* Плагіни можна завантажувати/гаряче підключати без перезапуску системи.
* Вбудовані типи вузлів: клітинний автомат, FFT, LLM-клієнт, Markdown-note, Plot, Embed, Composite Agent.
